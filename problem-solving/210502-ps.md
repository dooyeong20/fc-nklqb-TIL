# 백준 12025 - 장난꾸러기 영훈

## 브루트포스와 비트마스킹

비트마스킹은 이진수(`10011`)의 형태로 각각의 true(`1`)와 false(`0`) 등의 정보를 정수로 저장하는 것이다. 따라서 python을 예로 들었을 때 비트를 사용할 때와 리스트를 사용할 때를 아래와 같이 비교할 수 있다.

```python
visited = [0, 0, 0] # 리스트를 사용하여 8가지 상황을 나타낼 수 있음
bit = 0 # (000) 이진수를 사용해 000을 표현할 수 있다.


visited = [1, 0, 1] # 만약 1, 3번째의 flag만 true로 하고 싶을 때 이렇게 표현할 수 있다.
bit = 5	# (101) 이진수를 사용하면 101이라는 표현을 빠르고 효율적으로 표현할 수 있다.
```

이러한 비트마스킹은 서로 연산을 할때도 비트 연산자를(`|`, `&`, `~`, `<<`, `>>` 등) 이용해 빠르고 효율적으로 연산할 수 있다. 예를 들어서 `[0, 1, 0, 1]` 의 상황이 있다고 했을 때, 2번째 플래그와 3번째 요소를 참으로 바꾸고 싶다고 할 때 이를 비트연산자를 활용하면 아래와 같이 표현할 수 있다.

```python
bit = 5 #(0101)
result = 5 | 6 #(6 -> 0110) 즉, 5 | 6 == (0101 | 0110) == (0111)
```

이를 잘 활용하면 복잡하고 많은 연산이 필요한 상황에서 시간복잡도와 공간복잡도를 대폭 줄일 수 있다. 비트 마스킹을 몰랐을 때는 플래그 관리를 항상 변수 하나씩, 혹은 리스트나 set 형태로 관리했었는데 비트 마스킹이라는 것을 알게 된 이후에 문제를 풀 때 이를 적용해보니 너무 신세계였다.

## 비트마스킹을 활용한 예시 (문제풀이)

- [BOJ 12025 - 장난꾸러기 영훈](http://dooyeong20.github.io/2021/05/02/ps/ps-210502/)
  해당 문제는 비트마스킹을 활용해 `2^63-1` 이라는 엄청난 입력에 대해서 O(1)의 연산속도로 해답을 구할 수 있는 문제이다
